//===- FIRRTLFieldSource.cpp - Field Source Analysis ------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines a basic points-to like analysis.
// This analysis tracks any aggregate generated by an operation and maps any
// value derived from indexing of that aggregate back to the source of the
// aggregate along with a path through the type from the source. In parallel,
// this tracks any value which is an alias for a writable storage element, even
// if scalar.  This is sufficient to allow any value used on the LHS of a
// connect to be traced to its source, and to track any value which is a read
// of a storage element back to the source storage element.
//
// There is a redundant walk of the IR going on since flow is walking backwards
// over operations we've already visited.  We need to refactor foldFlow so we
// can build up the flow incrementally.
//
//===----------------------------------------------------------------------===//

#include "circt/Dialect/FIRRTL/FIRRTLFieldSource.h"

using namespace circt;
using namespace firrtl;

static size_t addID(size_t base, size_t inc) {
  if (base == ~0ULL)
    return ~0ULL;
  return base + inc;
}

// We allow recursion here since the recursion is actually on the type, not
// on the IR.
FieldSource::PathNode FieldSource::computeSrc(Value v) {
  if (auto ba = dyn_cast<BlockArgument>(v))
    return PathNode{v, 0};
  auto ii = paths.find(v);
  if (ii != paths.end())
    return ii->second;
  return TypeSwitch<Operation *, PathNode>(v.getDefiningOp())
      .template Case<SubfieldOp, OpenSubfieldOp>([&](auto indop) {
        auto value = indop.getInput();
        auto node = computeSrc(value);
        size_t newID = addID(node.fieldID,
                             indop.getInput().getType().base().getFieldID(indop.getFieldIndex()));
        PathNode retval{node.src, newID};
        paths[v] = retval;
        return retval;
      })
      .template Case<SubindexOp, OpenSubindexOp>([&](auto indop) {
        auto value = indop.getInput();
        auto node = nodeForValue(value);
        size_t newID = addID(node.fieldID,
                             indop.getInput().getType().base().getFieldID(indop.getIndex()));
        PathNode retval{node.src, newID};
        paths[v] = retval;
        return retval;
      })
      // Subaccesses can't maintain fieldID
      .template Case<SubaccessOp>([&](auto indop) {
        auto value = indop.getInput();
        auto node = nodeForValue(value);
        return PathNode{node.src, ~0ULL};
      })
      .Default([&](auto) {
        return PathNode{v, 0};
      });
}

FieldSource::PathNode FieldSource::nodeForValue(Value v) {
  auto p = computeSrc(v);
  assert(p.src);
  return p;
}
