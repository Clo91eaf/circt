//===- CapnpThreads.h - ESI cosim RPC ---------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Various classes used to implement the RPC server classes generated by
// CapnProto. Capnp C++ RPC servers are based on 'libkj' and its asynchrony
// model, which is very foreign. This is what the 'kj' namespace is along with
// alternate collections and other utility code.
//
//===----------------------------------------------------------------------===//

#ifndef COSIM_SERVER_H
#define COSIM_SERVER_H

#include "cosim/Endpoint.h"
#include "cosim/LowLevel.h"
#include "cosim/Utils.h"

#include <atomic>
#include <thread>

namespace kj {
class WaitScope;
} // namespace kj

namespace esi {
class Type;

namespace cosim {

/// Since Capnp is not thread-safe, client and server must be run in their own
/// threads and communicate with the outside world through thread safe channels.
class CapnpCosimThread {
public:
  CapnpCosimThread(FILE *logFile = nullptr);
  ~CapnpCosimThread();

  /// Stop the thread. This is a blocking call -- it will not return until the
  /// capnp thread has stopped.
  void stop();

  // Get the low level bridge.
  LowLevel *getLowLevel() { return &lowLevelBridge; }

  // Get the ESI version and compressed manifest. Returns false if the manifest
  // has yet to be loaded.
  bool getCompressedManifest(unsigned int &esiVersion,
                             std::vector<uint8_t> &manifest) {
    Lock l(m);
    esiVersion = this->esiVersion;
    manifest = compressedManifest;
    return this->esiVersion >= 0;
  }

  /// Send a message to an endpoint. Assumes that the endpoint exists and is
  /// connected! Fails silently if not!
  // TODO: replace this.
  void sendMessage(std::string epId, const MessageData &msg) {
    sendQueue.push(epId, msg);
  }

protected:
  using MessageEvent = std::pair<std::string, MessageData>;
  TSQueue<MessageEvent> sendQueue;

  /// Start capnp polling loop. Does not return until stop() is called. Must be
  /// called in the same thread the RPC server/client was created. 'poll' is
  /// called on each iteration of the loop.
  void loop(kj::WaitScope &waitScope, std::function<void()> poll);

  using Lock = std::lock_guard<std::mutex>;

  FILE *logFile;
  LowLevel lowLevelBridge;

  std::thread *myThread;
  volatile bool stopSig;
  std::mutex m;

  signed int esiVersion = -1;
  std::vector<uint8_t> compressedManifest;
};

/// The main RpcServer. Does not implement any capnp RPC interfaces but contains
/// the capnp main RPC server. We run the capnp server in its own thread to be
/// more responsive to network traffic and so as to not slow down the
/// simulation.
class RpcServer : public CapnpCosimThread {
public:
  using CapnpCosimThread::CapnpCosimThread;

  /// Start and stop the server thread.
  void run(uint16_t port);

  void setManifest(signed int esiVersion,
                   const std::vector<uint8_t> &manifest) {
    this->esiVersion = esiVersion;
    compressedManifest = manifest;
  }

  bool registerEndpoint(std::string epId, std::string typeId, Direction dir) {
    return endpoints.registerEndpoint(epId, typeId, dir);
  }

  // Get an endpoint by its ID.
  Endpoint *getEndpoint(std::string epId);

private:
  /// The thread's main loop function. Exits on shutdown.
  void mainLoop(uint16_t port);

  EndpointRegistry endpoints;
};

/// The Capnp RpcClient.
class RpcClient : public CapnpCosimThread {
  // To hide the ugly details of the capnp headers.
  struct Impl;
  friend struct Impl;

public:
  RpcClient() : impl(nullptr) {}
  ~RpcClient();

  /// Start client thread.
  void run(std::string host, uint16_t port);
  void connectSendEndpoint(const std::string &epId, const esi::Type *type);
  void
  connectRecvEndpoint(const std::string &epId, const esi::Type *type,
                      std::function<void(cosim::Endpoint::MessageDataPtr)> cb);

private:
  void mainLoop(std::string host, uint16_t port);

  std::atomic<Impl *> impl = nullptr;
};

} // namespace cosim
} // namespace esi

#endif
