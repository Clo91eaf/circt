// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
// RUN: circt-opt %s -llhd-early-code-motion | FileCheck %s

// CHECK-LABEL:   @check_dont_move_sideeffect
// CHECK-SAME:    (inout %[[VAL_0:.*]] : i32)
// CHECK:           llhd.process
// CHECK:           %[[VAL_1:.*]] = hw.constant 4 : i32
// CHECK:           %[[VAL_2:.*]] = llhd.constant_time <1ns, 0d, 0e>
// CHECK:           cf.br ^[[BB1:.+]]
// CHECK:         ^[[BB1]]:
// CHECK:           %[[VAL_3:.*]] = llhd.var %[[VAL_1]] : i32
// CHECK:           llhd.drv %[[VAL_0]], %[[VAL_1]] after %[[VAL_2]] : !hw.inout<i32>
// CHECK:           cf.br ^[[BB2:.+]]
// CHECK:         ^[[BB2]]:
// CHECK:           %[[VAL_4:.*]] = llhd.load %[[VAL_3]] : !llhd.ptr<i32>
// CHECK:           llhd.store %[[VAL_3]], %[[VAL_1]] : !llhd.ptr<i32>
// CHECK:           llhd.yield
// CHECK:         }
hw.module @check_dont_move_sideeffect(inout %sig : i32) {
  llhd.process {
    %c = hw.constant 4 : i32
    %time = llhd.constant_time <1ns, 0d, 0e>
    cf.br ^bb1
  ^bb1:
    %ptr = llhd.var %c : i32
    llhd.drv %sig, %c after %time : !hw.inout<i32>
    cf.br ^bb2
  ^bb2:
    %ld = llhd.load %ptr : !llhd.ptr<i32>
    llhd.store %ptr, %c : !llhd.ptr<i32>
    llhd.yield
  }
}

// Checks that prb is moved to predecessor block if it is in the same TR, but
// not if one predecessor has a wait terminator, but side-effect-free operations
// are moved freely
// CHECK-LABEL:   @check_move_prb
// CHECK-SAME:      (inout %[[VAL_0:.*]] : i32)
// CHECK:           llhd.process
// CHECK-DAG:        %[[VAL_1:.*]] = hw.constant 4 : i32
// CHECK-DAG:        %[[VAL_2:.*]] = comb.add %[[VAL_1]], %[[VAL_1]] : i32
// CHECK-DAG:        %[[VAL_3:.*]] = llhd.prb %[[VAL_0]] : !hw.inout<i32>
// CHECK-DAG:        %[[VAL_4:.*]] = llhd.prb %[[VAL_0]] : !hw.inout<i32>
// CHECK:           cf.br ^[[BB1:.+]]
// CHECK:         ^[[BB1]]:
// CHECK:           llhd.yield
// CHECK:         }
hw.module @check_move_prb(inout %sig : i32) {
  llhd.process {
    %c = hw.constant 4 : i32
    %prb1 = llhd.prb %sig : !hw.inout<i32>
    cf.br ^bb2
  ^bb2:
    %double = comb.add %c, %c : i32
    %prb2 = llhd.prb %sig : !hw.inout<i32>
    llhd.yield
  }
}

// CHECK-LABEL:   @check_blockarg
// CHECK-SAME:      (inout %[[VAL_0:.*]] : i32)
// CHECK:           llhd.process
// CHECK:           %[[VAL_1:.*]] = hw.constant 4 : i32
// CHECK:           cf.br ^[[BB1:.+]](%[[VAL_1]] : i32)
// CHECK:         ^[[BB1]](%[[VAL_2:.*]]: i32):
// CHECK:           %[[VAL_3:.*]] = comb.add %[[VAL_2]], %[[VAL_2]] : i32
// CHECK:           llhd.yield
// CHECK:         }
hw.module @check_blockarg(inout %sig : i32) {
  llhd.process {
    %c = hw.constant 4 : i32
    cf.br ^bb1(%c : i32)
  ^bb1(%a : i32):
    %double = comb.add %a, %a : i32
    llhd.yield
  }
}

// CHECK-LABEL:   @loop
// CHECK-SAME:      (inout %[[VAL_0:.*]] : i2)
// CHECK:           [[PRB:%.+]] = llhd.prb %in_i
// CHECK:           [[PROC:%.+]] = llhd.process
// CHECK:           %[[VAL_1:.*]] = hw.constant 0 : i32
// CHECK:           %[[VAL_5:.*]] = llhd.var %[[VAL_1]] : i32
// CHECK:           [[CHANGE:%.+]] = comb.icmp ne [[PRB]], [[PROC]] : i2
// CHECK:           %[[VAL_2:.*]] = hw.constant 2 : i32
// CHECK:           %[[VAL_3:.*]] = hw.constant 0 : i2
// CHECK:           %[[VAL_4:.*]] = hw.constant 1 : i32
// CHECK:           cf.cond_br [[CHANGE]], ^[[BB1:.+]], ^[[BB3:.+]]
// CHECK:         ^[[BB1]]:
// CHECK:           %[[VAL_6:.*]] = llhd.load %[[VAL_5]] : !llhd.ptr<i32>
// CHECK:           %[[VAL_7:.*]] = comb.icmp ult %[[VAL_6]], %[[VAL_2]] : i32
// CHECK:           cf.cond_br %[[VAL_7]], ^[[BB2:.+]], ^[[BB3]]
// CHECK:         ^[[BB2]]:
// CHECK:           %[[VAL_9:.*]] = llhd.load %[[VAL_5]] : !llhd.ptr<i32>
// CHECK:           %[[VAL_10:.*]] = comb.add %[[VAL_9]], %[[VAL_4]] : i32
// CHECK:           llhd.store %[[VAL_5]], %[[VAL_10]] : !llhd.ptr<i32>
// CHECK:           cf.br ^[[BB1]]
// CHECK:         ^[[BB3]]:
// CHECK:           llhd.yield [[PRB]] : i2
// CHECK:         }
hw.module @loop(inout %in_i : i2) {
  %prb0 = llhd.prb %in_i : !hw.inout<i2>
  %proc = llhd.process -> i2 {
    %0 = hw.constant 0 : i32
    %i = llhd.var %0 : i32
    %any_change = comb.icmp ne %prb0, %proc : i2
    cf.cond_br %any_change, ^loop_body, ^exit
  ^loop_body:
    %i_ld = llhd.load %i : !llhd.ptr<i32>
    %1 = hw.constant 2 : i32
    %2 = comb.icmp ult %i_ld, %1 : i32
    cf.cond_br %2, ^loop_continue, ^exit
  ^loop_continue:
    %3 = hw.constant 0 : i2
    %5 = hw.constant 1 : i32
    %prb = llhd.prb %in_i : !hw.inout<i2>
    %i_ld4 = llhd.load %i : !llhd.ptr<i32>
    %14 = comb.add %i_ld4, %5 : i32
    llhd.store %i, %14 : !llhd.ptr<i32>
    cf.br ^loop_body
  ^exit:
    llhd.yield %prb0 : i2
  }
}
